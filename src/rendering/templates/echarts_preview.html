<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>__TITLE__</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #0b1220; color: #e2e8f0; font-family: 'Segoe UI', 'Microsoft YaHei', system-ui; }
    #chart { width: 100%; height: 100%; }
    .header { position: absolute; top: 12px; left: 16px; z-index: 5; background: rgba(15, 23, 42, 0.7); padding: 8px 14px; border-radius: 10px; border: 1px solid rgba(148, 163, 184, 0.3); box-shadow: 0 10px 25px rgba(15, 23, 42, 0.35); }
    .header h1 { margin: 0; font-size: 16px; font-weight: 600; }
    .header span { font-size: 12px; color: #94a3b8; }
  </style>
</head>
<body>
  <div id="chart"></div>
  <div class="header">
    <h1 id="title"></h1>
    <span id="subtitle"></span>
  </div>
  <script>
    const dataCandles = __CANDLES__;
    const dataVolumes = __VOLUMES__;
    const dataMarkers = __MARKERS__;
    const dataOverlays = __OVERLAYS__;
    const dataStrokes = __STROKES__;
    const instrument = __INSTRUMENT__;
    const titleText = instrument.display || instrument.symbol || '__TITLE__';
    document.getElementById('title').innerText = titleText;
    document.getElementById('subtitle').innerText = instrument.exchange ? `${instrument.exchange}` : '';

    const categories = [];
    const values = [];
    const map = new Map();
    const volumeMap = new Map();
    dataCandles.forEach(item => {
      const time = item.time;
      categories.push(time);
      values.push([item.open, item.close, item.low, item.high]);
      map.set(String(time), item);
    });

    (dataVolumes || []).forEach(item => {
      if (!item) {
        return;
      }
      const key = String(item.time);
      const value = Number(item.value ?? item.volume ?? item.amount ?? item.turnover ?? 0);
      if (Number.isFinite(value)) {
        volumeMap.set(key, value);
      }
    });

    const markerPoints = (dataMarkers || []).map(marker => {
      const candle = map.get(String(marker.time)) || {};
      const fallback = marker.position === 'belowBar' ? candle.low : candle.high;
      const baseline = marker.price ?? fallback ?? candle.close ?? 0;
      const markerColor = marker.color || '#fcd34d';
      const isBelow = marker.position === 'belowBar';
      return {
        name: marker.text || '',
        coord: [marker.time, baseline],
        value: marker.text || '',
        itemStyle: {
          color: markerColor,
          borderColor: markerColor,
          borderWidth: 1.2,
        },
        symbol: marker.shape === 'arrowDown' ? 'triangle' : marker.shape === 'arrowUp' ? 'triangle' : 'circle',
        symbolRotate: marker.shape === 'arrowDown' ? 180 : 0,
        symbolSize: marker.size ? Math.max(12, marker.size * 5) : 16,
        symbolOffset: [0, isBelow ? 10 : -10],
        label: {
          color: '#f8fafc',
          fontSize: 11,
          backgroundColor: 'rgba(15, 23, 42, 0.9)',
          borderColor: markerColor,
          borderWidth: 1,
          borderRadius: 4,
          padding: [3, 6],
          position: isBelow ? 'top' : 'bottom',
          distance: 10,
        },
      };
    });

    const zoneRects = (dataOverlays || [])
      .filter(range => (range.kind || '').toLowerCase() !== 'major_wave' && (range.kind || '').toLowerCase() !== 'retest_link' && (range.kind || '').toLowerCase() !== 'line')
      .map(range => ({
        label: range.label || '',
        start: range.startTime || range.start || range.from,
        end: range.endTime || range.end || range.to,
        top: range.top ?? range.max ?? range.upper ?? null,
        bottom: range.bottom ?? range.min ?? range.lower ?? null,
        color: range.color || 'rgba(255, 215, 0, 0.15)',
        borderColor: (range.color && range.color.replace('0.15', '0.65')) || '#fcd34d',
      }));

    const lineOverlays = (dataOverlays || [])
      .filter(range => {
        const kind = (range.kind || '').toLowerCase();
        return kind === 'major_wave' || kind === 'retest_link' || kind === 'line';
      })
      .map((range, idx) => {
        const start = range.startTime || range.start || range.from;
        const end = range.endTime || range.end || range.to;
        const sp = range.startPrice ?? range.start_price ?? range.price ?? range.top ?? range.high ?? range.upper;
        const ep = range.endPrice ?? range.end_price ?? range.bottom ?? range.low ?? range.lower ?? sp;
        const color = range.color || (String(range.kind).toLowerCase() === 'major_wave' ? '#f59e0b' : '#94a3b8');
        const width = typeof range.lineWidth === 'number' ? range.lineWidth : 2;
        return {
          coords: [
            [start, sp],
            [end, ep],
          ],
          lineStyle: {
            color,
            width,
            type: range.lineStyle === 'dashed' ? 'dashed' : range.lineStyle === 'dotted' ? 'dotted' : 'solid',
            opacity: 0.9,
          },
          name: range.label || `${range.kind || 'line'}#${idx + 1}`,
        };
      });

    const strokeLines = (dataStrokes || []).map(stroke => ({
      coords: [
        [stroke.startTime, stroke.startPrice],
        [stroke.endTime, stroke.endPrice],
      ],
      lineStyle: {
        color: stroke.direction === 'up' ? '#34d399' : '#f87171',
        width: 2.6,
      },
    }));

    const chart = echarts.init(document.getElementById('chart'), null, {
      renderer: window.devicePixelRatio > 1.4 ? 'svg' : 'canvas',
      devicePixelRatio: Math.min(window.devicePixelRatio, 2),
    });

    const volumeSeriesData = categories.map((time, idx) => {
      const candle = map.get(String(time)) || dataCandles[idx] || {};
      const ref = volumeMap.has(String(time)) ? volumeMap.get(String(time)) : (candle.volume ?? candle.Volume ?? candle.vol ?? candle.amount ?? candle.turnover ?? 0);
      const value = Number(ref) || 0;
      const color = (candle.close ?? 0) >= (candle.open ?? 0) ? '#ea580c' : '#10b981';
      return { value, itemStyle: { color } };
    });

    const option = {
      animation: false,
      backgroundColor: '#0b1220',
      textStyle: { color: '#e2e8f0' },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'cross' },
        backgroundColor: 'rgba(15,23,42,0.9)',
        formatter: (params) => {
          if (!params || !params.length) return '';
          const idx = params[0].dataIndex;
          const candle = dataCandles[idx] || {};
          const open = candle.open ?? candle.Open ?? null;
          const high = candle.high ?? candle.High ?? null;
          const low = candle.low ?? candle.Low ?? null;
          const close = candle.close ?? candle.Close ?? null;
          const prev = dataCandles[idx - 1] || {};
          const prevClose = prev.close ?? prev.Close ?? null;
          let pct = null;
          if (prevClose !== null && prevClose !== 0 && close != null) {
            pct = ((close - prevClose) / prevClose) * 100;
          } else {
            const pctField = candle.pct_chg ?? candle.pct ?? candle.change_pct ?? candle.chg ?? null;
            if (pctField !== null && pctField !== undefined) {
              pct = Number(pctField);
            }
          }
          const lines = [];
          const nameLine = instrument.name || instrument.display || instrument.symbol || '';
          if (nameLine) {
            lines.push(`标的：${nameLine}`);
          }
          lines.push(`时间：${params[0].axisValue}`);
          if (open != null) lines.push(`开盘：${open}`);
          if (high != null) lines.push(`最高：${high}`);
          if (low != null) lines.push(`最低：${low}`);
          if (close != null) lines.push(`收盘：${close}`);
          if (pct != null && Number.isFinite(pct)) lines.push(`涨跌：${Number(pct).toFixed(2)}%`);
          return lines.join('<br/>');
        },
      },
      axisPointer: { link: [{ xAxisIndex: 'all' }], snap: true },
      grid: [
        { left: 48, right: 28, top: 40, height: '58%' },
        { left: 48, right: 28, height: '18%', bottom: 60 },
      ],
      xAxis: [
        {
          type: 'category',
          data: categories,
          boundaryGap: true,
          axisLine: { lineStyle: { color: '#475569' } },
          axisLabel: { color: '#94a3b8' },
          splitLine: { show: false },
          axisPointer: { show: true },
        },
        {
          type: 'category',
          gridIndex: 1,
          data: categories,
          boundaryGap: true,
          axisLine: { lineStyle: { color: '#475569' } },
          axisLabel: { color: '#94a3b8' },
          axisTick: { show: false },
          splitLine: { show: false },
        },
      ],
      yAxis: [
        {
          scale: true,
          axisLine: { lineStyle: { color: '#475569' } },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } },
          axisLabel: { color: '#cbd5f5' },
        },
        {
          gridIndex: 1,
          axisLine: { lineStyle: { color: '#475569' } },
          splitLine: { show: false },
          axisLabel: { color: '#94a3b8' },
        },
      ],
      dataZoom: [
        { type: 'inside', xAxisIndex: [0, 1], start: 70, end: 100 },
        { xAxisIndex: [0, 1], start: 70, end: 100, height: 26, bottom: 18, borderColor: '#475569', textStyle: { color: '#94a3b8' } },
      ],
      series: [
        {
          name: instrument.display || 'K线',
          type: 'candlestick',
          data: values,
          xAxisIndex: 0,
          yAxisIndex: 0,
          itemStyle: {
            color: '#ef4444',
            color0: '#22c55e',
            borderColor: '#ef4444',
            borderColor0: '#22c55e',
            borderWidth: 1.2,
          },
          markPoint: {
            symbol: 'triangle',
            symbolSize: 12,
            symbolKeepAspect: true,
            data: markerPoints,
            label: { formatter: param => param.value || '', fontSize: 11 },
          },
          z: 1,
        },
        {
          name: '趋势线',
          type: 'line',
          data: values.map((row, idx) => [categories[idx], row[1]]),
          smooth: true,
          lineStyle: { color: '#64748b', width: 1, opacity: 0.35 },
          showSymbol: false,
          xAxisIndex: 0,
          yAxisIndex: 0,
          z: 0,
        },
        {
          name: '中枢',
          type: 'custom',
          xAxisIndex: 0,
          yAxisIndex: 0,
          renderItem: (params, api) => {
            const zone = zoneRects[params.dataIndex];
            if (!zone || zone.top == null || zone.bottom == null) {
              return null;
            }
            const start = api.coord([zone.start, zone.bottom]);
            const end = api.coord([zone.end, zone.top]);
            const x = Math.min(start[0], end[0]);
            const y = Math.min(start[1], end[1]);
            const width = Math.abs(end[0] - start[0]);
            const height = Math.abs(end[1] - start[1]);
            return {
              type: 'rect',
              shape: { x, y, width, height },
              style: { fill: zone.color, stroke: zone.borderColor, lineWidth: 1 },
            };
          },
          data: zoneRects,
          z: 2,
        },
        {
          name: '笔',
          type: 'lines',
          coordinateSystem: 'cartesian2d',
          polyline: false,
          xAxisIndex: 0,
          yAxisIndex: 0,
          data: strokeLines,
          lineStyle: { width: 3 },
          effect: {
            show: true,
            trailLength: 0,
            symbolSize: 6,
            color: '#f8fafc',
          },
          z: 3,
        },
        {
          name: '主波段/回踩线',
          type: 'lines',
          coordinateSystem: 'cartesian2d',
          polyline: false,
          xAxisIndex: 0,
          yAxisIndex: 0,
          data: lineOverlays,
          lineStyle: { width: 2 },
          symbol: 'none',
          z: 2,
        },
        {
          name: '成交量',
          type: 'bar',
          xAxisIndex: 1,
          yAxisIndex: 1,
          barWidth: '60%',
          data: volumeSeriesData,
          tooltip: { valueFormatter: value => `${value ?? 0}` },
          z: 0,
        },
      ],
    };

    chart.setOption(option);
    window.addEventListener('resize', () => {
      chart.resize();
    });
  </script>
</body>
</html>
