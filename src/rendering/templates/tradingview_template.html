<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lightweight Charts PyQt Demo</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; background: #f1f4f9; }
    #chart { position: relative; display: flex; flex-direction: column; height: 100%; width: 100%; padding: 18px 22px 22px; box-sizing: border-box; background: linear-gradient(180deg, #f6f8fb 0%, #e9eef6 100%); }
    .panel { position: relative; width: 100%; background: #ffffff; border-radius: 14px; box-shadow: 0 14px 36px rgba(15, 23, 42, 0.12); overflow: hidden; }
    #main-chart { flex: 1 1 auto; min-height: 320px; }
    #chart-divider { flex: 0 0 auto; width: 88%; height: 18px; margin: 16px auto; background: linear-gradient(90deg, rgba(99, 121, 181, 0.18) 0%, rgba(161, 176, 211, 0.36) 50%, rgba(99, 121, 181, 0.18) 100%); border-radius: 12px; box-shadow: inset 0 1px 3px rgba(15, 23, 42, 0.08); pointer-events: none; }
    #volume-chart { flex: 0 0 auto; min-height: 200px; }
    #tooltip { position: absolute; top: 18px; right: 18px; background: rgba(255, 255, 255, 0.94); border-radius: 8px; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15); padding: 10px 14px; font-size: 13px; color: #2d3240; pointer-events: none; line-height: 1.5; display: none; white-space: nowrap; border: 1px solid rgba(120, 132, 168, 0.35); backdrop-filter: blur(4px); z-index: 10; }
    .overlay-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 4; }
  </style>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div id="chart">
    <div id="main-chart" class="panel"></div>
    <div id="chart-divider"></div>
    <div id="volume-chart" class="panel"></div>
    <div id="tooltip"></div>
  </div>
  <script>
    const initialCandles = __CANDLES__;
    const initialVolumes = __VOLUMES__;
    const instrumentInfo = __INSTRUMENT__;
    const signalMarkers = (() => {
      try {
        return typeof __SIGNALS__ === 'string' ? JSON.parse(__SIGNALS__) : __SIGNALS__;
      } catch (e) {
        console.error('Failed to parse __SIGNALS__:', e);
        return [];
      }
    })();
    const overlayRanges = (() => {
      try {
        return typeof __OVERLAYS__ === 'string' ? JSON.parse(__OVERLAYS__) : __OVERLAYS__;
      } catch (e) {
        console.error('Failed to parse __OVERLAYS__:', e);
        return [];
      }
    })();

    console.log('=== MARKERS DEBUG ===');
    console.log('signalMarkers:', signalMarkers);
    console.log('signalMarkers length:', signalMarkers ? signalMarkers.length : 'null');

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    const pad2 = (value) => String(value).padStart(2, '0');

    const normalizeTime = (time) => {
      const compose = (year, month, day) => `${year}-${Number(month)}-${Number(day)}`;

      if (typeof time === 'string') {
        const parts = time.split(/[-/]/);
        if (parts.length === 3) {
          return compose(parts[0], parts[1], parts[2]);
        }
        return time;
      }

      if (typeof time === 'number') {
        const date = new Date(time * 1000);
        return compose(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
      }

      if (time && typeof time === 'object') {
        if ('year' in time && 'month' in time && 'day' in time) {
          return compose(time.year, time.month, time.day);
        }
        if ('businessDay' in time) {
          const bd = time.businessDay;
          return compose(bd.year, bd.month, bd.day);
        }
        if ('time' in time) {
          return normalizeTime(time.time);
        }
      }

      return String(time);
    };

    const toBusinessDay = (value) => {
      if (value && typeof value === 'object') {
        if ('year' in value && 'month' in value && 'day' in value) {
          return value;
        }
        if ('businessDay' in value) {
          return value.businessDay;
        }
      }

      if (typeof value === 'string') {
        const parts = value.split(/[-/]/).map(Number);
        if (parts.length === 3) {
          const [year, month, day] = parts;
          return { year, month, day };
        }
      }

      if (typeof value === 'number') {
        const date = new Date(value * 1000);
        return { year: date.getUTCFullYear(), month: date.getUTCMonth() + 1, day: date.getUTCDate() };
      }

      return value;
    };

    const toUTCDate = (value) => {
      const bd = toBusinessDay(value);
      if (!bd || typeof bd.year !== 'number' || typeof bd.month !== 'number' || typeof bd.day !== 'number') {
        return null;
      }
      return new Date(Date.UTC(bd.year, bd.month - 1, bd.day));
    };

    const formatDisplayDate = (dateStr) => {
      if (!dateStr) {
        return '';
      }
      const parts = String(dateStr).split(/[-/]/);
      if (parts.length === 3) {
        const [year, month, day] = parts;
        return `${year}-${Number(month)}-${Number(day)}`;
      }
      return dateStr;
    };

    document.addEventListener('DOMContentLoaded', () => {
      const container = document.getElementById('chart');
      const mainContainer = document.getElementById('main-chart');
      const volumeContainer = document.getElementById('volume-chart');
      const divider = document.getElementById('chart-divider');
      const tooltip = document.getElementById('tooltip');

      const candleData = (initialCandles || []).map(item => ({
        time: toBusinessDay(item.time),
        open: Number(item.open),
        high: Number(item.high),
        low: Number(item.low),
        close: Number(item.close),
      }));

      const volumeData = (initialVolumes || []).map(item => ({
        time: toBusinessDay(item.time),
        value: Number(item.value),
        color: item.color,
      }));

      const lineData = candleData.map(item => ({ time: item.time, value: item.close }));

      const candleDataMap = new Map(candleData.map(item => [normalizeTime(item.time), item]));
      const volumeDataMap = new Map(volumeData.map(item => [normalizeTime(item.time), item.value]));

      const previousCloseMap = new Map();
      let previousCloseValue = null;
      for (const item of candleData) {
        const key = normalizeTime(item.time);
        if (previousCloseValue !== null) {
          previousCloseMap.set(key, previousCloseValue);
        }
        previousCloseValue = item.close;
      }

      const normalizedMarkers = Array.isArray(signalMarkers)
        ? signalMarkers
            .map(marker => {
              const rawTime = marker && (marker.time || marker.date || marker.timestamp);
              if (!rawTime) {
                return null;
              }
              // 将标记时间转换为与K线数据相同的时间格式 (business day object)
              const timeValue = toBusinessDay(rawTime);
              if (!timeValue) {
                return null;
              }
              const position = marker.position || 'aboveBar';
              const shape = marker.shape || (position === 'belowBar' ? 'arrowDown' : 'arrowUp');
              return {
                id: marker.id || `marker_${Date.now()}_${Math.random()}`,
                time: timeValue,  // 使用business day object，与K线数据一致
                position,
                shape,
                color: marker.color || '#ff6f00',
                text: marker.text ? String(marker.text) : '',
                size: marker.size || 1,
              };
            })
            .filter(Boolean)
        : [];

      console.log('signalMarkers:', signalMarkers ? signalMarkers.length : 'null');
      console.log('normalizedMarkers:', normalizedMarkers.length);
      if (normalizedMarkers.length > 0) {
        console.log('First normalized marker:', normalizedMarkers[0]);
        console.log('First marker time type:', typeof normalizedMarkers[0].time, normalizedMarkers[0].time);
      }

      // 调试：检查波峰和波谷标记的数量
      const peakMarkers = normalizedMarkers.filter(m => m.text && m.text.includes('波峰'));
      const valleyMarkers = normalizedMarkers.filter(m => m.text && m.text.includes('波谷'));
      console.log('Peak markers:', peakMarkers.length, 'Valley markers:', valleyMarkers.length);
      if (peakMarkers.length > 0) {
        console.log('First peak marker:', peakMarkers[0]);
      }
      if (valleyMarkers.length > 0) {
        console.log('First valley marker:', valleyMarkers[0]);
      }

      console.log('About to call applyMarkers with normalizedMarkers:', normalizedMarkers.length);

      const businessDayToKey = (bd) => `${bd.year}-${pad2(bd.month)}-${pad2(bd.day)}`;
      const businessDayToTimestamp = (bd) => {
        const millis = Date.UTC(bd.year, bd.month - 1, bd.day);
        return Number.isFinite(millis) ? Math.floor(millis / 1000) : null;
      };

      const convertRangeTime = (value) => {
        if (value == null) {
          return null;
        }
        const normalized = normalizeTime(value);
        const bd = toBusinessDay(normalized);
        if (!bd || typeof bd.year !== 'number') {
          return null;
        }
        return bd;
      };

      const buildOverlayTime = (value) => {
        const bd = convertRangeTime(value);
        if (!bd) {
          return null;
        }
        const key = businessDayToKey(bd);
        const timestamp = businessDayToTimestamp(bd);
        if (timestamp == null) {
          return null;
        }
        return { bd, key, timestamp };
      };

      const normalizedOverlays = Array.isArray(overlayRanges)
        ? overlayRanges
            .map(range => {
              const start = buildOverlayTime(range.startTime || range.start || range.from);
              const end = buildOverlayTime(range.endTime || range.end || range.to);
              const topValue = Number(range.top ?? range.high ?? range.upper ?? range.max);
              const bottomValue = Number(range.bottom ?? range.low ?? range.lower ?? range.min);
              if (!start || !end || !Number.isFinite(topValue) || !Number.isFinite(bottomValue)) {
                return null;
              }
              const upper = Math.max(topValue, bottomValue);
              const lower = Math.min(topValue, bottomValue);
              const rawKind = String(range.kind || '').toLowerCase();
              const mappedKind = rawKind === 'downtrend'
                ? 'downtrend'
                : rawKind === 'uptrend'
                  ? 'uptrend'
                  : rawKind === 'sideways'
                    ? 'sideways'
                    : 'sideways';
              return {
                startTime: start.bd,
                endTime: end.bd,
                startKey: start.key,
                endKey: end.key,
                top: upper,
                bottom: lower,
                kind: mappedKind,
                strength: typeof range.strength === 'number' ? range.strength : 0,
                color: range.color,
                label: range.label || '',
              };
            })
            .filter(Boolean)
        : [];

      const mainChart = LightweightCharts.createChart(mainContainer, {
        layout: {
          background: { color: '#ffffff' },
          textColor: '#333333',
        },
        grid: {
          vertLines: { color: 'rgba(120, 120, 120, 0.08)' },
          horzLines: { visible: false },
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
          vertLine: {
            color: 'rgba(120, 120, 120, 0.6)',
            labelBackgroundColor: '#4c525e',
          },
          horzLine: {
            color: 'rgba(120, 120, 120, 0.6)',
            labelBackgroundColor: '#4c525e',
          },
        },
        rightPriceScale: { borderVisible: false },
        timeScale: {
          visible: false,
          secondsVisible: false,
          borderVisible: false,
        },
        localization: {
          locale: 'zh-CN',
          timeFormatter: (time) => formatDisplayDate(normalizeTime(time)),
        },
      });

      const volumeChart = LightweightCharts.createChart(volumeContainer, {
        layout: {
          background: { color: '#ffffff' },
          textColor: '#333333',
        },
        grid: {
          vertLines: { color: 'rgba(120, 120, 120, 0.08)' },
          horzLines: { visible: false },
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
          vertLine: {
            color: 'rgba(120, 120, 120, 0.4)',
            labelBackgroundColor: '#4c525e',
          },
          horzLine: { visible: false },
        },
        rightPriceScale: {
          scaleMargins: { top: 0.1, bottom: 0 },
          borderVisible: false,
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
          borderVisible: false,
          tickMarkFormatter: (time) => formatDisplayDate(normalizeTime(time)),
        },
        localization: {
          locale: 'zh-CN',
          timeFormatter: (time) => formatDisplayDate(normalizeTime(time)),
        },
      });

      const volumeAxisFormatter = new Intl.NumberFormat('zh-CN', { minimumFractionDigits: 0, maximumFractionDigits: 2 });

      const candleSeries = mainChart.addCandlestickSeries({
        upColor: '#ffffff',
        borderUpColor: '#f03752',
        wickUpColor: '#f03752',
        downColor: '#13b355',
        borderDownColor: '#13b355',
        wickDownColor: '#13b355',
        priceScaleId: 'right',
        lastValueVisible: false,
        priceLineVisible: false,
      });

      const lineSeries = mainChart.addLineSeries({
        color: '#2979ff',
        lineWidth: 1.2,
        priceScaleId: 'right',
        lastValueVisible: false,
        priceLineVisible: false,
      });

      const volumeSeries = volumeChart.addHistogramSeries({
        priceFormat: {
          type: 'custom',
          minMove: 0.01,
          formatter: value => `${volumeAxisFormatter.format(value)} 万`,
        },
        priceScaleId: 'right',
        base: 0,
        lastValueVisible: false,
        priceLineVisible: false,
      });

      // 创建趋势线系列 - 使用线图系列
      const trendLineSeries = mainChart.addLineSeries({
        color: '#ff6f00',
        lineWidth: 2,
        priceScaleId: 'right',
        lastValueVisible: false,
        priceLineVisible: false,
        crosshairMarkerVisible: false,
      });

      // 创建高级趋势可视化系列

      // 趋势价格线管理函数
      let trendPriceLines = [];

      let overlayCanvas = null;
      let overlayCtx = null;

      function ensureOverlayCanvas() {
        if (!normalizedOverlays.length) {
          return false;
        }
        if (overlayCanvas && overlayCtx) {
          return true;
        }
        overlayCanvas = document.createElement('canvas');
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.width = '100%';
        overlayCanvas.style.height = '100%';
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '10';
        mainContainer.appendChild(overlayCanvas);
        overlayCtx = overlayCanvas.getContext('2d');
        console.info('[overlay] Canvas created:', !!overlayCtx);
        return !!overlayCtx;
      }

      candleSeries.setData(candleData);
      lineSeries.setData([]);
      volumeSeries.setData(volumeData);

      let syncingRanges = false;
      const LINE_THRESHOLD = 1000;
      let usingLineMode = false;

      ensureOverlayCanvas();

      const getOverlayStyles = (range) => {
        // 直接使用range.color，如果没有则根据kind设置默认颜色
        const defaultColor = range.kind === 'downtrend' ? 'rgba(255,0,0,0.15)' : range.kind === 'uptrend' ? 'rgba(0,255,0,0.15)' : 'rgba(255,255,0,0.15)';
        return {
          fill: range.color || defaultColor,
          stroke: range.kind === 'downtrend' ? 'red' : range.kind === 'uptrend' ? 'green' : 'yellow',
          text: '#222',
          label: range.label || range.kind || '',
        };
      };

      let overlayDrawRequested = false;
      const performOverlayDraw = (trigger = '') => {
        if (!normalizedOverlays.length) {
          console.info('[overlay] No overlays to draw');
          return;
        }
        if (!ensureOverlayCanvas()) {
          console.warn('[overlay] Failed to create canvas');
          return;
        }

        let drawnCount = 0;

        const rect = mainContainer.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;

        if (!width || !height) {
          console.info(`[overlay] Skip draw (${trigger}) width=${width} height=${height}`);
          return;
        }

        // 确保canvas尺寸正确
        overlayCanvas.width = width;
        overlayCanvas.height = height;
        overlayCanvas.style.width = `${width}px`;
        overlayCanvas.style.height = `${height}px`;

        // 重新定位canvas到正确位置
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.width = `${width}px`;
        overlayCanvas.style.height = `${height}px`;
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '10';

        // 确保canvas在mainContainer中
        if (overlayCanvas.parentElement !== mainContainer) {
          mainContainer.appendChild(overlayCanvas);
        }

        overlayCtx.clearRect(0, 0, width, height);

        console.info(`[overlay] Drawing ${normalizedOverlays.length} overlays on ${width}x${height} canvas`);

        const timeScaleApi = mainChart.timeScale();
        const activeSeries = usingLineMode ? lineSeries : candleSeries;
        const priceScaleApi = candleSeries.priceScale(); // 总是使用candleSeries的价格轴，因为它始终有数据

        if (!priceScaleApi) {
          console.warn('[overlay] Price scale API not available');
          return;
        }

        // 手动计算价格坐标 - 使用实际数据范围
        // 计算数据中的价格范围
        let minPrice = Infinity;
        let maxPrice = -Infinity;

        candleData.forEach(candle => {
          minPrice = Math.min(minPrice, candle.low);
          maxPrice = Math.max(maxPrice, candle.high);
        });

        // 扩大范围以留出边距
        const priceRange = maxPrice - minPrice;
        const margin = priceRange * 0.05; // 5%的边距
        minPrice -= margin;
        maxPrice += margin;

        const chartHeight = height;

        // 计算每个价格单位对应的像素数
        const pixelPerPrice = chartHeight / (maxPrice - minPrice);

        // 计算坐标（Y轴从上到下增加，所以要反转）
        const calculatePriceCoordinate = (price) => {
          return (maxPrice - price) * pixelPerPrice;
        };

        normalizedOverlays.forEach(range => {
          // 过滤该区间内的K线数据
          const candlesInRange = candleData.filter(candle => {
            const candleTime = normalizeTime(candle.time);
            const startTime = normalizeTime(range.startTime);
            const endTime = normalizeTime(range.endTime);
            return candleTime >= startTime && candleTime <= endTime;
          });

          if (candlesInRange.length === 0) {
            return;
          }

          // 计算每个K线的坐标
          const candleCoords = candlesInRange.map(candle => {
            const timeX = timeScaleApi.timeToCoordinate(candle.time);
            const highY = calculatePriceCoordinate(candle.high);
            const lowY = calculatePriceCoordinate(candle.low);
            return { timeX, highY, lowY };
          }).filter(coord => coord.timeX != null && coord.highY != null && coord.lowY != null);

          if (candleCoords.length === 0) {
            return;
          }

          const styles = getOverlayStyles(range);

          // 如果K线太多，使用矩形近似以提高性能
          if (candleCoords.length > 200) {
            // 计算区域边界
            const minX = Math.min(...candleCoords.map(c => c.timeX));
            const maxX = Math.max(...candleCoords.map(c => c.timeX));
            const minY = Math.min(...candleCoords.map(c => c.lowY));
            const maxY = Math.max(...candleCoords.map(c => c.highY));

            overlayCtx.fillStyle = styles.fill;
            overlayCtx.fillRect(minX, minY, maxX - minX, maxY - minY);
            overlayCtx.strokeStyle = styles.stroke;
            overlayCtx.lineWidth = 2;
            overlayCtx.strokeRect(minX, minY, maxX - minX, maxY - minY);

            // 添加标签
            if ((maxX - minX) > 40 && (maxY - minY) > 20) {
              overlayCtx.font = '12px "Segoe UI", "Microsoft YaHei", sans-serif';
              overlayCtx.fillStyle = styles.text;
              overlayCtx.fillText(styles.label, minX + 6, minY + 16);
            }
          } else {
            // 绘制多边形区域：连接所有K线的高点和低点
            overlayCtx.beginPath();
            overlayCtx.moveTo(candleCoords[0].timeX, candleCoords[0].lowY);

            // 从左到右连接所有高点
            for (let i = 0; i < candleCoords.length; i++) {
              overlayCtx.lineTo(candleCoords[i].timeX, candleCoords[i].highY);
            }

            // 从右到左连接所有低点
            for (let i = candleCoords.length - 1; i >= 0; i--) {
              overlayCtx.lineTo(candleCoords[i].timeX, candleCoords[i].lowY);
            }

            overlayCtx.closePath();

            overlayCtx.fillStyle = styles.fill;
            overlayCtx.fill();
            overlayCtx.strokeStyle = styles.stroke;
            overlayCtx.lineWidth = 2;
            overlayCtx.stroke();

            // 添加标签（如果区域足够大）
            const minX = Math.min(...candleCoords.map(c => c.timeX));
            const maxX = Math.max(...candleCoords.map(c => c.timeX));
            const minY = Math.min(...candleCoords.map(c => c.lowY));
            const maxY = Math.max(...candleCoords.map(c => c.highY));
            const widthPx = maxX - minX;
            const heightPx = maxY - minY;

            if (widthPx > 40 && heightPx > 20) {
              overlayCtx.font = '12px "Segoe UI", "Microsoft YaHei", sans-serif';
              overlayCtx.fillStyle = styles.text;
              overlayCtx.fillText(styles.label, minX + 6, minY + 16);
            }
          }

          drawnCount += 1;
        });

        if (drawnCount === 0) {
          console.info(`[overlay] Draw skipped. Time=${skippedForTime} Price=${skippedForPrice}`);
        } else {
          console.info(`[overlay] Successfully drew ${drawnCount} overlay blocks`);
        }
      };

      let overlayDrawTimeout = null;
      const scheduleOverlayDraw = () => {
        if (overlayDrawRequested) {
          return;
        }
        overlayDrawRequested = true;

        // 清除之前的超时
        if (overlayDrawTimeout) {
          clearTimeout(overlayDrawTimeout);
        }

        // 设置新的超时，使用节流确保缩放停止后才重绘
        overlayDrawTimeout = setTimeout(() => {
          overlayDrawTimeout = null;
          window.requestAnimationFrame(() => {
            overlayDrawRequested = false;
            performOverlayDraw('raf');
          });
        }, 100); // 增加延迟到100ms
      };

      window.__PYQT_OVERLAY_REFRESH = () => {
        scheduleOverlayDraw();
      };

      const applyMarkers = (useLineMode, visibleRange = null) => {
        console.log('applyMarkers called with useLineMode:', useLineMode, 'normalizedMarkers length:', normalizedMarkers.length);
        if (!normalizedMarkers.length) {
          console.log('No markers to apply, clearing all');
          candleSeries.setMarkers([]);
          lineSeries.setMarkers([]);
          return;
        }

        let markersToApply = normalizedMarkers;

        // 如果提供了可见范围，则只显示该范围内的标记
        if (visibleRange) {
          const visibleFrom = visibleRange.from;
          const visibleTo = visibleRange.to;
          console.log('Filtering markers for visible range:', visibleFrom, 'to', visibleTo);

          markersToApply = normalizedMarkers.filter(marker => {
            // 将标记时间转换为索引
            const markerTime = marker.time;
            // 找到这个时间在candleData中的索引
            const markerIndex = candleData.findIndex(candle => {
              return candle.time.year === markerTime.year &&
                     candle.time.month === markerTime.month &&
                     candle.time.day === markerTime.day;
            });

            return markerIndex >= visibleFrom && markerIndex <= visibleTo;
          });

          console.log('Filtered markers:', markersToApply.length, 'out of', normalizedMarkers.length);
        }

        // 始终将标记应用到两个series，确保无论哪个是活跃的都能显示标记
        console.log('Applying', markersToApply.length, 'markers to both series');
        candleSeries.setMarkers(markersToApply);
        lineSeries.setMarkers(markersToApply);
        console.log('Markers applied successfully');

        // 检查标记是否真的被设置了
        setTimeout(() => {
          const candleMarkers = candleSeries.markers();
          const lineMarkers = lineSeries.markers();
          console.log('Candle markers after setting:', candleMarkers ? candleMarkers.length : 'null');
          console.log('Line markers after setting:', lineMarkers ? lineMarkers.length : 'null');
        }, 100);
      };

      // 在设置range后调用applyMarkers，确保使用正确的usingLineMode
      setTimeout(() => {
        applyMarkers(usingLineMode);
        scheduleOverlayDraw('init');
      }, 100);

      const THREE_YEARS_MS = 3 * 365 * 24 * 60 * 60 * 1000;
      const MIN_VISIBLE_BARS = 120;

      const computeDefaultRange = () => {
        if (!candleData.length) {
          return null;
        }
        // 显示最近200个交易日的数据，而不是所有历史数据
        // 这样可以显示最新的数据，像东方财富等券商软件一样
        const totalBars = candleData.length;
        const visibleBars = Math.min(200, totalBars); // 显示最近200个交易日
        return { from: totalBars - visibleBars, to: totalBars - 1 };
      };

      const defaultRange = computeDefaultRange();
      if (defaultRange) {
        mainChart.timeScale().setVisibleLogicalRange(defaultRange);
        volumeChart.timeScale().setVisibleLogicalRange(defaultRange);
      } else {
        mainChart.timeScale().fitContent();
        volumeChart.timeScale().fitContent();
      }

      // 在设置range后调用applyMarkers，确保使用正确的usingLineMode
      setTimeout(() => {
        const initialRange = mainChart.timeScale().getVisibleLogicalRange();
        applyMarkers(usingLineMode, initialRange);
        scheduleOverlayDraw('init');
      }, 100);

      const syncRanges = (source, target) => {
        if (syncingRanges) {
          return;
        }
        const logical = source.timeScale().getVisibleLogicalRange();
        if (!logical) {
          return;
        }
        syncingRanges = true;
        target.timeScale().setVisibleLogicalRange(logical);
        syncingRanges = false;
      };

      mainChart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
        syncRanges(mainChart, volumeChart);
        if (!range) {
          scheduleOverlayDraw();
          return;
        }
        const bars = range.to - range.from;

        if (!usingLineMode && bars > LINE_THRESHOLD) {
          console.log('Switching to lineSeries mode, bars:', bars);
          candleSeries.setData([]);
          lineSeries.setData(lineData);
          usingLineMode = true;
          applyMarkers(usingLineMode, range);
          setTimeout(() => scheduleOverlayDraw(), 100);
          return;
        }
        if (usingLineMode && bars < LINE_THRESHOLD * 0.7) {
          console.log('Switching back to candleSeries mode, bars:', bars);
          lineSeries.setData([]);
          candleSeries.setData(candleData);
          usingLineMode = false;
          applyMarkers(usingLineMode, range);
        } else {
          // 即使没有切换模式，也要根据新的可见范围重新过滤标记
          applyMarkers(usingLineMode, range);
        }
        setTimeout(() => scheduleOverlayDraw(), 100);
      });

      volumeChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        syncRanges(volumeChart, mainChart);
      });

      const rightScale = mainChart.priceScale('right');
      if (rightScale && typeof rightScale.subscribePriceScaleWidthChange === 'function') {
        rightScale.subscribePriceScaleWidthChange(() => scheduleOverlayDraw());
      }

      if (rightScale && typeof rightScale.subscribeVisiblePriceRangeChange === 'function') {
        rightScale.subscribeVisiblePriceRangeChange(() => scheduleOverlayDraw());
      }

      const priceFormatter = new Intl.NumberFormat('zh-CN', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      const volumeFormatter = new Intl.NumberFormat('zh-CN', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
      const changeValueFormatter = new Intl.NumberFormat('zh-CN', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

      const instrumentDisplay = () => {
        if (!instrumentInfo) {
          return { primary: '—', secondary: '' };
        }
        const primaryRaw = instrumentInfo.display && instrumentInfo.display.trim
          ? instrumentInfo.display.trim()
          : [instrumentInfo.symbol, instrumentInfo.name].filter(Boolean).map(String).join(' · ');
        const primary = primaryRaw || instrumentInfo.symbol || instrumentInfo.name || '—';
        let secondary = '';
        if (instrumentInfo.name && instrumentInfo.symbol && instrumentInfo.name !== instrumentInfo.symbol) {
          secondary = String(instrumentInfo.name).trim();
          if (secondary === primary) {
            secondary = '';
          }
        }
        return { primary, secondary };
      };

      const updateTooltipForTime = (time, source) => {
        if (!time) {
          if (source !== 'init') {
            tooltip.style.display = 'none';
          }
          return;
        }

        const key = normalizeTime(time);
        const candle = candleDataMap.get(key);
        if (!candle) {
          if (source !== 'init') {
            tooltip.style.display = 'none';
          }
          return;
        }

        const volumeValue = volumeDataMap.has(key) ? volumeDataMap.get(key) : 0;
        const prevClose = previousCloseMap.has(key) ? previousCloseMap.get(key) : null;

        let changeDisplay = '—';
        if (typeof prevClose === 'number' && prevClose !== 0) {
          const diffPct = ((candle.close - prevClose) / prevClose) * 100;
          const sign = diffPct > 0 ? '+' : diffPct < 0 ? '-' : '';
          const color = diffPct > 0 ? '#f03752' : diffPct < 0 ? '#13b355' : '#4c525e';
          changeDisplay = `<span style="color:${color};">${sign}${changeValueFormatter.format(Math.abs(diffPct))}%</span>`;
        }

        const instrumentLine = (() => {
          const info = instrumentDisplay();
          if (!info.primary || info.primary === '—') {
            return null;
          }
          const label = info.secondary && info.secondary !== info.primary
            ? `${info.primary}`
            : info.primary;
          return `<strong>${label}</strong>`;
        })();

        const tooltipLines = [
          instrumentLine,
          `日期：${formatDisplayDate(key)}`,
          `开盘：${priceFormatter.format(candle.open)}`,
          `最高：${priceFormatter.format(candle.high)}`,
          `最低：${priceFormatter.format(candle.low)}`,
          `收盘：${priceFormatter.format(candle.close)}`,
          `成交量：${volumeFormatter.format(volumeValue)} 万股`,
          `涨跌幅：${changeDisplay}`,
        ].filter(Boolean).join('<br />');

        tooltip.innerHTML = tooltipLines;

        if (source === 'init') {
          tooltip.style.display = 'none';
          return;
        }

        tooltip.style.display = 'block';

        if (typeof volumeChart.setCrosshairPosition === 'function' && source !== 'volume') {
          volumeChart.setCrosshairPosition(volumeValue, time, volumeSeries);
        }
        if (typeof mainChart.setCrosshairPosition === 'function' && source !== 'main') {
          mainChart.setCrosshairPosition(candle.close, time, candleSeries);
        }
      };

      const hideTooltip = () => {
        tooltip.style.display = 'none';
        if (typeof volumeChart.clearCrosshairPosition === 'function') {
          volumeChart.clearCrosshairPosition();
        }
      };

      mainChart.subscribeCrosshairMove((param) => {
        if (!param || param.time === undefined || !param.point) {
          hideTooltip();
          return;
        }
        const withinX = param.point.x >= 0 && param.point.x <= mainContainer.clientWidth;
        const withinY = param.point.y >= 0 && param.point.y <= mainContainer.clientHeight;
        if (!withinX || !withinY) {
          hideTooltip();
          return;
        }
        updateTooltipForTime(param.time, 'main');
      });

      volumeChart.subscribeCrosshairMove((param) => {
        if (!param || param.time === undefined || !param.point) {
          hideTooltip();
          return;
        }
        const withinX = param.point.x >= 0 && param.point.x <= volumeContainer.clientWidth;
        const withinY = param.point.y >= 0 && param.point.y <= volumeContainer.clientHeight;
        if (!withinX || !withinY) {
          hideTooltip();
          return;
        }
        updateTooltipForTime(param.time, 'volume');
      });

      if (candleData.length > 0) {
        const lastBar = candleData[candleData.length - 1];
        updateTooltipForTime(lastBar.time, 'init');
      }

      const handleResize = () => {
        const style = window.getComputedStyle(container);
        const paddingLeft = parseFloat(style.paddingLeft) || 0;
        const paddingRight = parseFloat(style.paddingRight) || 0;
        const paddingTop = parseFloat(style.paddingTop) || 0;
        const paddingBottom = parseFloat(style.paddingBottom) || 0;
        const dividerHeight = divider ? divider.offsetHeight : 0;

        const availableWidth = container.clientWidth - paddingLeft - paddingRight;
        const rawHeight = container.clientHeight - paddingTop - paddingBottom - dividerHeight;
        const minimumTotal = 260 + 120;
        const safeHeight = Math.max(minimumTotal, rawHeight);

        let mainHeight = Math.round(safeHeight * 0.72);
        let volumeHeight = safeHeight - mainHeight;

        if (mainHeight < 260) {
          mainHeight = 260;
          volumeHeight = safeHeight - mainHeight;
        }

        if (volumeHeight < 120) {
          volumeHeight = 120;
          mainHeight = safeHeight - volumeHeight;
        }

        mainContainer.style.height = `${mainHeight}px`;
        volumeContainer.style.height = `${volumeHeight}px`;
        mainContainer.style.width = `${availableWidth}px`;
        volumeContainer.style.width = `${availableWidth}px`;

        mainChart.resize(availableWidth, mainHeight);
        volumeChart.resize(availableWidth, volumeHeight);
        scheduleOverlayDraw();
      };

      window.addEventListener('resize', handleResize);

      if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(container);
      }

      handleResize();
    });
  </script>
</body>
</html>